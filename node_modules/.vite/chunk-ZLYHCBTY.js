import {
  LabelMixin
} from "./chunk-M63LEPKS.js";
import {
  Debouncer,
  animationFrame
} from "./chunk-RUXXNLZ4.js";
import {
  css
} from "./chunk-AILCGYJH.js";
import {
  FlattenedNodesObserver
} from "./chunk-OIQZQ3SK.js";
import {
  dedupingMixin
} from "./chunk-GN24F3WZ.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-J6GZCXFQ.js";

// node_modules/.pnpm/@vaadin/vaadin-lumo-styles@22.0.0-beta2/node_modules/@vaadin/vaadin-lumo-styles/mixins/helper.js
var helper = css`
  :host([has-helper]) [part='helper-text']::before {
    content: '';
    display: block;
    height: 0.4em;
  }

  [part='helper-text'] {
    display: block;
    color: var(--lumo-secondary-text-color);
    font-size: var(--lumo-font-size-xs);
    line-height: var(--lumo-line-height-xs);
    margin-left: calc(var(--lumo-border-radius-m) / 4);
    transition: color 0.2s;
  }

  :host(:hover:not([readonly])) [part='helper-text'] {
    color: var(--lumo-body-text-color);
  }

  :host([disabled]) [part='helper-text'] {
    color: var(--lumo-disabled-text-color);
    -webkit-text-fill-color: var(--lumo-disabled-text-color);
  }

  :host([has-helper][theme~='helper-above-field']) [part='helper-text']::before {
    display: none;
  }

  :host([has-helper][theme~='helper-above-field']) [part='helper-text']::after {
    content: '';
    display: block;
    height: 0.4em;
  }

  :host([has-helper][theme~='helper-above-field']) [part='label'] {
    order: 0;
    padding-bottom: 0.4em;
  }

  :host([has-helper][theme~='helper-above-field']) [part='helper-text'] {
    order: 1;
  }

  :host([has-helper][theme~='helper-above-field']) [part='label'] + * {
    order: 2;
  }

  :host([has-helper][theme~='helper-above-field']) [part='error-message'] {
    order: 3;
  }
`;

// node_modules/.pnpm/@vaadin/field-base@22.0.0-beta2/node_modules/@vaadin/field-base/src/validate-mixin.js
var ValidateMixin = dedupingMixin((superclass) => class ValidateMixinClass extends superclass {
  static get properties() {
    return {
      invalid: {
        type: Boolean,
        reflectToAttribute: true,
        notify: true,
        value: false
      },
      required: {
        type: Boolean,
        reflectToAttribute: true
      }
    };
  }
  validate() {
    return !(this.invalid = !this.checkValidity());
  }
  checkValidity() {
    return !this.required || !!this.value;
  }
});

// node_modules/.pnpm/@vaadin/field-base@22.0.0-beta2/node_modules/@vaadin/field-base/src/field-mixin.js
var FieldMixin = (superclass) => class FieldMixinClass extends ValidateMixin(LabelMixin(superclass)) {
  static get properties() {
    return {
      ariaTarget: {
        type: Object,
        observer: "_ariaTargetChanged"
      },
      errorMessage: {
        type: String
      },
      helperText: {
        type: String,
        observer: "_helperTextChanged"
      },
      _helperId: String
    };
  }
  get slots() {
    return __spreadProps(__spreadValues({}, super.slots), {
      "error-message": () => {
        const error = document.createElement("div");
        error.textContent = this.errorMessage;
        return error;
      }
    });
  }
  static get observers() {
    return [
      "__ariaChanged(invalid, _helperId, required)",
      "__observeOffsetHeight(errorMessage, invalid, label, helperText)",
      "_updateErrorMessage(invalid, errorMessage)"
    ];
  }
  get _errorNode() {
    return this._getDirectSlotChild("error-message");
  }
  get _helperNode() {
    return this._getDirectSlotChild("helper");
  }
  get _ariaAttr() {
    return "aria-describedby";
  }
  constructor() {
    super();
    const uniqueId = FieldMixinClass._uniqueFieldId = 1 + FieldMixinClass._uniqueFieldId || 0;
    this._errorId = `error-${this.localName}-${uniqueId}`;
    this._helperId = `helper-${this.localName}-${uniqueId}`;
    this.__savedHelperId = this._helperId;
  }
  ready() {
    super.ready();
    const error = this._errorNode;
    if (error) {
      error.id = this._errorId;
      this.__applyCustomError();
      this._updateErrorMessage(this.invalid, this.errorMessage);
    }
    const helper2 = this._helperNode;
    if (helper2) {
      this.__applyCustomHelper(helper2);
    }
    this.__helperSlot = this.shadowRoot.querySelector('[name="helper"]');
    this.__helperSlotObserver = new FlattenedNodesObserver(this.__helperSlot, (info) => {
      const helper3 = this._currentHelper;
      const newHelper = info.addedNodes.find((node) => node !== helper3);
      const oldHelper = info.removedNodes.find((node) => node === helper3);
      if (newHelper) {
        if (helper3 && helper3.isConnected) {
          this.removeChild(helper3);
        }
        this.__applyCustomHelper(newHelper);
        this.__helperIdObserver = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (mutation.type === "attributes" && mutation.attributeName === "id" && mutation.target === this._currentHelper && mutation.target.id !== this.__savedHelperId) {
              this.__updateHelperId(mutation.target);
            }
          });
        });
        this.__helperIdObserver.observe(newHelper, { attributes: true });
      } else if (oldHelper) {
        if (this.__helperIdObserver) {
          this.__helperIdObserver.disconnect();
        }
        this.__applyDefaultHelper(this.helperText);
      }
    });
  }
  __applyCustomError() {
    const error = this.__errorMessage;
    if (error && error !== this.errorMessage) {
      this.errorMessage = error;
      delete this.__errorMessage;
    }
  }
  __applyCustomHelper(helper2) {
    this.__updateHelperId(helper2);
    this._currentHelper = helper2;
    this.__toggleHasHelper(helper2.children.length > 0 || this.__isNotEmpty(helper2.textContent));
  }
  __isNotEmpty(helperText) {
    return helperText && helperText.trim() !== "";
  }
  __attachDefaultHelper() {
    let helper2 = this.__defaultHelper;
    if (!helper2) {
      helper2 = document.createElement("div");
      helper2.setAttribute("slot", "helper");
      this.__defaultHelper = helper2;
    }
    helper2.id = this.__savedHelperId;
    this.appendChild(helper2);
    this._currentHelper = helper2;
    return helper2;
  }
  __applyDefaultHelper(helperText) {
    let helper2 = this._helperNode;
    const hasHelperText = this.__isNotEmpty(helperText);
    if (hasHelperText && !helper2) {
      helper2 = this.__attachDefaultHelper();
    }
    if (helper2 && helper2 === this.__defaultHelper) {
      helper2.textContent = helperText;
    }
    this.__toggleHasHelper(hasHelperText);
  }
  __toggleHasHelper(hasHelper) {
    this.toggleAttribute("has-helper", hasHelper);
  }
  _dispatchIronResizeEventIfNeeded(prop, value) {
    const oldSize = "__old" + prop;
    if (this[oldSize] !== void 0 && this[oldSize] !== value) {
      this.dispatchEvent(new CustomEvent("iron-resize", { bubbles: true, composed: true }));
    }
    this[oldSize] = value;
  }
  __observeOffsetHeight() {
    this.__observeOffsetHeightDebouncer = Debouncer.debounce(this.__observeOffsetHeightDebouncer, animationFrame, () => {
      this._dispatchIronResizeEventIfNeeded("Height", this.offsetHeight);
    });
  }
  _updateErrorMessage(invalid, errorMessage) {
    const error = this._errorNode;
    if (!error) {
      return;
    }
    if (error.textContent && !errorMessage) {
      this.__errorMessage = error.textContent.trim();
    }
    const hasError = Boolean(invalid && errorMessage);
    error.textContent = hasError ? errorMessage : "";
    this.toggleAttribute("has-error-message", hasError);
    if (hasError) {
      error.setAttribute("role", "alert");
    } else {
      error.removeAttribute("role");
    }
  }
  __updateHelperId(customHelper) {
    let newId;
    if (customHelper.id) {
      newId = customHelper.id;
    } else {
      newId = this.__savedHelperId;
      customHelper.id = newId;
    }
    this._helperId = newId;
  }
  _helperTextChanged(helperText) {
    this.__applyDefaultHelper(helperText);
  }
  _ariaTargetChanged(target) {
    if (target) {
      this._updateAriaAttribute(target, this.invalid, this._helperId);
      this._updateAriaRequiredAttribute(target, this.required);
    }
  }
  _updateAriaAttribute(target, invalid, helperId) {
    const attr = this._ariaAttr;
    if (target && attr) {
      const ariaIds = attr === "aria-describedby" ? [helperId] : [this._labelId, helperId];
      if (invalid) {
        ariaIds.push(this._errorId);
      }
      target.setAttribute(attr, ariaIds.join(" "));
    }
  }
  _updateAriaRequiredAttribute(target, required) {
    if (target !== this) {
      return;
    }
    if (required) {
      target.setAttribute("aria-required", true);
    } else {
      target.removeAttribute("aria-required");
    }
  }
  __ariaChanged(invalid, helperId, required) {
    this._updateAriaAttribute(this.ariaTarget, invalid, helperId);
    this._updateAriaRequiredAttribute(this.ariaTarget, required);
  }
};

export {
  helper,
  ValidateMixin,
  FieldMixin
};
/**
 * @license
 * Copyright (c) 2021 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-ZLYHCBTY.js.map

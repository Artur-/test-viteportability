import {
  TimePicker
} from "./chunk-Q4ADGUHB.js";
import {
  customField
} from "./chunk-BF3GGUEH.js";
import {
  DatePicker,
  dateEquals
} from "./chunk-RCWXWISD.js";
import "./chunk-KAFY6EEA.js";
import "./chunk-B3QZ3KZ5.js";
import "./chunk-UCCJDHTP.js";
import "./chunk-5IY3DZOH.js";
import {
  inputFieldShared
} from "./chunk-FXDBZGKI.js";
import "./chunk-4YC3PK3E.js";
import "./chunk-HDZUK7DT.js";
import {
  FieldMixin,
  helper
} from "./chunk-ZLYHCBTY.js";
import {
  requiredField
} from "./chunk-G7RHUQOA.js";
import "./chunk-PSOWVSIC.js";
import "./chunk-2QU43T3L.js";
import {
  SlotMixin
} from "./chunk-M63LEPKS.js";
import "./chunk-3XUR5GO6.js";
import "./chunk-BDIP7LEN.js";
import "./chunk-SWEWJURK.js";
import "./chunk-2WAZ2OPO.js";
import "./chunk-2ELV5DK6.js";
import "./chunk-OE4BTSWX.js";
import "./chunk-MRY7CVKJ.js";
import "./chunk-EGRHWZRV.js";
import "./chunk-X5RCOUJL.js";
import "./chunk-6AVOQNQ4.js";
import "./chunk-W5WIT4JA.js";
import {
  DisabledMixin
} from "./chunk-VBV2WJY4.js";
import "./chunk-VD23N2FG.js";
import "./chunk-Y3KRHGW3.js";
import {
  ElementMixin
} from "./chunk-6TGXYB6C.js";
import "./chunk-RUXXNLZ4.js";
import "./chunk-LQ3LJ4SC.js";
import "./chunk-NJGA5XKB.js";
import "./chunk-UGRMV72L.js";
import "./chunk-SOI6EIGV.js";
import "./chunk-ESTDBV53.js";
import "./chunk-YRRWCJGV.js";
import "./chunk-CBMAWUYA.js";
import "./chunk-J5VFVUBT.js";
import "./chunk-XQZS3VUL.js";
import "./chunk-GBF7XL6S.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-LYMUE5P7.js";
import {
  css
} from "./chunk-AILCGYJH.js";
import "./chunk-BHAZN44K.js";
import "./chunk-D4OAJTCX.js";
import "./chunk-BFXXBFHG.js";
import "./chunk-VXX3KNUF.js";
import "./chunk-ZNYRZO32.js";
import "./chunk-DYEQLZCC.js";
import "./chunk-KFEHHBXX.js";
import "./chunk-3GXLJMXG.js";
import "./chunk-XLE2I272.js";
import "./chunk-CGDXGGUU.js";
import "./chunk-5BR6CINV.js";
import "./chunk-5SUV3F4B.js";
import "./chunk-OIQZQ3SK.js";
import {
  PolymerElement
} from "./chunk-YGHRZLAU.js";
import {
  html
} from "./chunk-5VJMXRGB.js";
import "./chunk-XALJ24ZG.js";
import "./chunk-GN24F3WZ.js";
import "./chunk-HDWYYSVS.js";
import "./chunk-PN57JW3E.js";
import "./chunk-FHJNRKKV.js";
import "./chunk-JJSCQCEV.js";
import "./chunk-PHKVH5MM.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-J6GZCXFQ.js";

// node_modules/.pnpm/@vaadin/date-time-picker@22.0.0-beta2/node_modules/@vaadin/date-time-picker/theme/lumo/vaadin-date-time-picker-styles.js
registerStyles("vaadin-date-time-picker", [requiredField, helper, customField], {
  moduleId: "lumo-date-time-picker"
});
registerStyles("vaadin-date-time-picker-date-picker", css`
    :host {
      margin-right: 2px;
    }

    /* RTL specific styles */
    :host([dir='rtl']) {
      margin-right: auto;
      margin-left: 2px;
    }

    [part~='input-field'] {
      border-top-right-radius: 0;
      border-bottom-right-radius: 0;
    }

    /* RTL specific styles */
    :host([dir='rtl']) [part~='input-field'] {
      border-radius: var(--lumo-border-radius-m);
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
    }
  `, { moduleId: "lumo-date-time-picker-date-picker" });
registerStyles("vaadin-date-time-picker-time-picker", css`
    [part~='input-field'] {
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
    }

    /* RTL specific styles */
    :host([dir='rtl']) [part~='input-field'] {
      border-radius: var(--lumo-border-radius-m);
      border-top-right-radius: 0;
      border-bottom-right-radius: 0;
    }
  `, { moduleId: "lumo-date-time-picker-time-picker" });

// node_modules/.pnpm/@vaadin/date-time-picker@22.0.0-beta2/node_modules/@vaadin/date-time-picker/src/vaadin-date-time-picker-date-picker.js
var DateTimePickerDatePicker = class extends DatePicker {
  static get is() {
    return "vaadin-date-time-picker-date-picker";
  }
};
customElements.define(DateTimePickerDatePicker.is, DateTimePickerDatePicker);

// node_modules/.pnpm/@vaadin/date-time-picker@22.0.0-beta2/node_modules/@vaadin/date-time-picker/src/vaadin-date-time-picker-time-picker.js
var DateTimePickerTimePicker = class extends TimePicker {
  static get is() {
    return "vaadin-date-time-picker-time-picker";
  }
};
customElements.define(DateTimePickerTimePicker.is, DateTimePickerTimePicker);

// node_modules/.pnpm/@vaadin/date-time-picker@22.0.0-beta2/node_modules/@vaadin/date-time-picker/src/vaadin-date-time-picker.js
registerStyles("vaadin-date-time-picker", inputFieldShared, { moduleId: "vaadin-date-time-picker" });
var getPropertyFromPrototype = function(clazz, prop) {
  while (clazz) {
    if (clazz.properties && clazz.properties[prop]) {
      return clazz.properties[prop];
    }
    clazz = clazz.__proto__;
  }
};
var datePickerClass = customElements.get("vaadin-date-time-picker-date-picker");
var timePickerClass = customElements.get("vaadin-date-time-picker-time-picker");
var datePickerI18nDefaults = getPropertyFromPrototype(datePickerClass, "i18n").value();
var timePickerI18nDefaults = getPropertyFromPrototype(timePickerClass, "i18n").value();
var datePickerI18nProps = Object.keys(datePickerI18nDefaults);
var timePickerI18nProps = Object.keys(timePickerI18nDefaults);
var DateTimePicker = class extends FieldMixin(SlotMixin(DisabledMixin(ThemableMixin(ElementMixin(PolymerElement))))) {
  static get template() {
    return html`
      <style>
        .vaadin-date-time-picker-container {
          --vaadin-field-default-width: auto;
        }

        .slots {
          display: flex;
          --vaadin-field-default-width: 12em;
        }

        [part='date'],
        .slots ::slotted([slot='date-picker']) {
          pointer-events: all;
          min-width: 0;
          flex: 1 1 auto;
        }

        [part='time'],
        .slots ::slotted([slot='time-picker']) {
          pointer-events: all;
          min-width: 0;
          flex: 1 1.65 auto;
        }
      </style>

      <div class="vaadin-date-time-picker-container">
        <div part="label" on-click="focus">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true"></span>
        </div>

        <div class="slots">
          <slot name="date-picker" id="dateSlot"></slot>
          <slot name="time-picker" id="timeSlot"></slot>
        </div>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>
    `;
  }
  static get is() {
    return "vaadin-date-time-picker";
  }
  static get properties() {
    return {
      name: {
        type: String
      },
      value: {
        type: String,
        notify: true,
        value: "",
        observer: "__valueChanged"
      },
      min: {
        type: String,
        observer: "__minChanged"
      },
      max: {
        type: String,
        observer: "__maxChanged"
      },
      __minDateTime: {
        type: Date,
        value: ""
      },
      __maxDateTime: {
        type: Date,
        value: ""
      },
      datePlaceholder: {
        type: String
      },
      timePlaceholder: {
        type: String
      },
      step: {
        type: Number
      },
      initialPosition: String,
      showWeekNumbers: {
        type: Boolean
      },
      autoOpenDisabled: Boolean,
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      autofocus: {
        type: Boolean
      },
      __selectedDateTime: {
        type: Date
      },
      i18n: {
        type: Object,
        value: () => Object.assign({}, datePickerI18nDefaults, timePickerI18nDefaults)
      }
    };
  }
  static get observers() {
    return [
      "__selectedDateTimeChanged(__selectedDateTime)",
      "__datePlaceholderChanged(datePlaceholder)",
      "__timePlaceholderChanged(timePlaceholder)",
      "__stepChanged(step)",
      "__initialPositionChanged(initialPosition)",
      "__showWeekNumbersChanged(showWeekNumbers)",
      "__requiredChanged(required)",
      "__invalidChanged(invalid)",
      "__disabledChanged(disabled)",
      "__readonlyChanged(readonly)",
      "__i18nChanged(i18n.*)",
      "__autoOpenDisabledChanged(autoOpenDisabled)",
      "__themeChanged(theme, __datePicker, __timePicker)",
      "__pickersChanged(__datePicker, __timePicker)"
    ];
  }
  get slots() {
    return __spreadProps(__spreadValues({}, super.slots), {
      "date-picker": () => {
        const element = document.createElement("vaadin-date-time-picker-date-picker");
        element.__defaultPicker = true;
        return element;
      },
      "time-picker": () => {
        const element = document.createElement("vaadin-date-time-picker-time-picker");
        element.__defaultPicker = true;
        return element;
      }
    });
  }
  constructor() {
    super();
    this.__defaultDateMinMaxValue = void 0;
    this.__defaultTimeMinValue = "00:00:00.000";
    this.__defaultTimeMaxValue = "23:59:59.999";
    this.__changeEventHandler = this.__changeEventHandler.bind(this);
    this.__valueChangedEventHandler = this.__valueChangedEventHandler.bind(this);
  }
  ready() {
    super.ready();
    this.addEventListener("focusout", (e) => {
      if (e.relatedTarget !== this.__datePicker.$.overlay) {
        this.validate();
      }
    });
    this.__datePickerChanged();
    this.__timePickerChanged();
    this.$.dateSlot.addEventListener("slotchange", this.__datePickerChanged.bind(this));
    this.$.timeSlot.addEventListener("slotchange", this.__timePickerChanged.bind(this));
    if (this.autofocus && !this.disabled) {
      window.requestAnimationFrame(() => this.focus());
    }
    this.setAttribute("role", "group");
    this.ariaTarget = this;
  }
  get _ariaAttr() {
    return "aria-labelledby";
  }
  __filterElements(node) {
    return node.nodeType === Node.ELEMENT_NODE;
  }
  focus() {
    this.__datePicker.focus();
  }
  __syncI18n(target, source, props) {
    props = props || Object.keys(source.i18n);
    props.forEach((prop) => {
      if (source.i18n && source.i18n.hasOwnProperty(prop)) {
        target.set(`i18n.${prop}`, source.i18n[prop]);
      }
    });
  }
  __changeEventHandler(event) {
    event.stopPropagation();
    if (this.__dispatchChangeForValue === this.value) {
      this.__dispatchChange();
      this.validate();
    }
    this.__dispatchChangeForValue = void 0;
  }
  __addInputListeners(node) {
    node.addEventListener("change", this.__changeEventHandler);
    node.addEventListener("value-changed", this.__valueChangedEventHandler);
  }
  __removeInputListeners(node) {
    node.removeEventListener("change", this.__changeEventHandler);
    node.removeEventListener("value-changed", this.__valueChangedEventHandler);
  }
  __datePickerChanged() {
    const datePicker = this._getDirectSlotChild("date-picker");
    if (this.__datePicker === datePicker || !datePicker) {
      return;
    }
    if (this.__datePicker) {
      this.__removeInputListeners(this.__datePicker);
      this.__datePicker.remove();
    }
    this.__addInputListeners(datePicker);
    this.__datePicker = datePicker;
    if (datePicker.__defaultPicker) {
      datePicker.placeholder = this.datePlaceholder;
      datePicker.invalid = this.invalid;
      datePicker.initialPosition = this.initialPosition;
      datePicker.showWeekNumbers = this.showWeekNumbers;
      this.__syncI18n(datePicker, this, datePickerI18nProps);
    } else {
      this.datePlaceholder = datePicker.placeholder;
      this.initialPosition = datePicker.initialPosition;
      this.showWeekNumbers = datePicker.showWeekNumbers;
      this.__syncI18n(this, datePicker, datePickerI18nProps);
    }
    datePicker.min = this.__formatDateISO(this.__minDateTime, this.__defaultDateMinMaxValue);
    datePicker.max = this.__formatDateISO(this.__maxDateTime, this.__defaultDateMinMaxValue);
    datePicker.required = this.required;
    datePicker.disabled = this.disabled;
    datePicker.readonly = this.readonly;
    datePicker.autoOpenDisabled = this.autoOpenDisabled;
    datePicker.validate = () => {
    };
    datePicker._validateInput = () => {
    };
  }
  __timePickerChanged() {
    const timePicker = this._getDirectSlotChild("time-picker");
    if (this.__timePicker === timePicker || !timePicker) {
      return;
    }
    if (this.__timePicker) {
      this.__removeInputListeners(this.__timePicker);
      this.__timePicker.remove();
    }
    this.__addInputListeners(timePicker);
    this.__timePicker = timePicker;
    if (timePicker.__defaultPicker) {
      timePicker.placeholder = this.timePlaceholder;
      timePicker.step = this.step;
      timePicker.invalid = this.invalid;
      this.__syncI18n(timePicker, this, timePickerI18nProps);
    } else {
      this.timePlaceholder = timePicker.placeholder;
      this.step = timePicker.step;
      this.__syncI18n(this, timePicker, timePickerI18nProps);
    }
    this.__updateTimePickerMinMax();
    timePicker.required = this.required;
    timePicker.disabled = this.disabled;
    timePicker.readonly = this.readonly;
    timePicker.autoOpenDisabled = this.autoOpenDisabled;
    timePicker.validate = () => {
    };
  }
  __updateTimePickerMinMax() {
    if (this.__timePicker && this.__datePicker) {
      const selectedDate = this.__parseDate(this.__datePicker.value);
      const isMinMaxSameDay = dateEquals(this.__minDateTime, this.__maxDateTime);
      const oldTimeValue = this.__timePicker.value;
      if (this.__minDateTime && dateEquals(selectedDate, this.__minDateTime) || isMinMaxSameDay) {
        this.__timePicker.min = this.__dateToIsoTimeString(this.__minDateTime);
      } else {
        this.__timePicker.min = this.__defaultTimeMinValue;
      }
      if (this.__maxDateTime && dateEquals(selectedDate, this.__maxDateTime) || isMinMaxSameDay) {
        this.__timePicker.max = this.__dateToIsoTimeString(this.__maxDateTime);
      } else {
        this.__timePicker.max = this.__defaultTimeMaxValue;
      }
      if (this.__timePicker.value !== oldTimeValue) {
        this.__timePicker.value = oldTimeValue;
      }
    }
  }
  __i18nChanged(changeRecord) {
    this.__datePickerChanged();
    if (this.__datePicker) {
      this.__datePicker.set(changeRecord.path, changeRecord.value);
    }
    this.__timePickerChanged();
    if (this.__timePicker) {
      this.__timePicker.set(changeRecord.path, changeRecord.value);
    }
  }
  __datePlaceholderChanged(datePlaceholder) {
    if (this.__datePicker) {
      this.__datePicker.placeholder = datePlaceholder;
    }
  }
  __timePlaceholderChanged(timePlaceholder) {
    if (this.__timePicker) {
      this.__timePicker.placeholder = timePlaceholder;
    }
  }
  __stepChanged(step) {
    if (this.__timePicker && this.__timePicker.step !== step) {
      this.__timePicker.step = step;
    }
  }
  __initialPositionChanged(initialPosition) {
    if (this.__datePicker) {
      this.__datePicker.initialPosition = initialPosition;
    }
  }
  __showWeekNumbersChanged(showWeekNumbers) {
    if (this.__datePicker) {
      this.__datePicker.showWeekNumbers = showWeekNumbers;
    }
  }
  __invalidChanged(invalid) {
    if (this.__datePicker) {
      this.__datePicker.invalid = invalid;
    }
    if (this.__timePicker) {
      this.__timePicker.invalid = invalid;
    }
  }
  __requiredChanged(required) {
    if (this.__datePicker) {
      this.__datePicker.required = required;
    }
    if (this.__timePicker) {
      this.__timePicker.required = required;
    }
  }
  __disabledChanged(disabled) {
    if (this.__datePicker) {
      this.__datePicker.disabled = disabled;
    }
    if (this.__timePicker) {
      this.__timePicker.disabled = disabled;
    }
  }
  __readonlyChanged(readonly) {
    if (this.__datePicker) {
      this.__datePicker.readonly = readonly;
    }
    if (this.__timePicker) {
      this.__timePicker.readonly = readonly;
    }
  }
  __parseDate(str) {
    return datePickerClass.prototype._parseDate(str);
  }
  __formatDateISO(date, defaultValue) {
    if (!date) {
      return defaultValue;
    }
    return datePickerClass.prototype._formatISO(date);
  }
  __formatTimeISO(time) {
    return timePickerI18nDefaults.formatTime(time);
  }
  __parseTimeISO(str) {
    return timePickerI18nDefaults.parseTime(str);
  }
  __parseDateTime(str) {
    const [dateValue, timeValue] = str.split("T");
    if (!(dateValue && timeValue)) {
      return;
    }
    const date = this.__parseDate(dateValue);
    if (!date) {
      return;
    }
    const time = this.__parseTimeISO(timeValue);
    if (!time) {
      return;
    }
    date.setHours(parseInt(time.hours));
    date.setMinutes(parseInt(time.minutes || 0));
    date.setSeconds(parseInt(time.seconds || 0));
    date.setMilliseconds(parseInt(time.milliseconds || 0));
    return date;
  }
  __formatDateTime(date) {
    if (!date) {
      return "";
    }
    const dateValue = this.__formatDateISO(date, "");
    const timeValue = this.__dateToIsoTimeString(date);
    return `${dateValue}T${timeValue}`;
  }
  __dateToIsoTimeString(date) {
    return this.__formatTimeISO(this.__validateTime({
      hours: date.getHours(),
      minutes: date.getMinutes(),
      seconds: date.getSeconds(),
      milliseconds: date.getMilliseconds()
    }));
  }
  __validateTime(timeObject) {
    if (timeObject) {
      timeObject.seconds = this.__stepSegment < 3 ? void 0 : timeObject.seconds;
      timeObject.milliseconds = this.__stepSegment < 4 ? void 0 : timeObject.milliseconds;
    }
    return timeObject;
  }
  get __inputs() {
    return [this.__datePicker, this.__timePicker];
  }
  checkValidity() {
    const hasInvalidFields = this.__inputs.some((input) => !input.checkValidity());
    const hasEmptyFields = this.required && this.__inputs.some((el) => !el.value);
    if (hasInvalidFields || hasEmptyFields) {
      return false;
    }
    return true;
  }
  get __stepSegment() {
    const step = this.step == void 0 ? 60 : parseFloat(this.step);
    if (step % 3600 === 0) {
      return 1;
    } else if (step % 60 === 0 || !step) {
      return 2;
    } else if (step % 1 === 0) {
      return 3;
    } else if (step < 1) {
      return 4;
    }
  }
  __dateTimeEquals(date1, date2) {
    if (!dateEquals(date1, date2)) {
      return false;
    }
    return date1.getHours() === date2.getHours() && date1.getMinutes() === date2.getMinutes() && date1.getSeconds() === date2.getSeconds() && date1.getMilliseconds() === date2.getMilliseconds();
  }
  __handleDateTimeChange(property, parsedProperty, value, oldValue) {
    if (!value) {
      this[property] = "";
      this[parsedProperty] = "";
      return;
    }
    const dateTime = this.__parseDateTime(value);
    if (!dateTime) {
      this[property] = oldValue;
      return;
    }
    if (!this.__dateTimeEquals(this[parsedProperty], dateTime)) {
      this[parsedProperty] = dateTime;
    }
  }
  __valueChanged(value, oldValue) {
    this.__handleDateTimeChange("value", "__selectedDateTime", value, oldValue);
    if (oldValue !== void 0) {
      this.__dispatchChangeForValue = value;
    }
    this.toggleAttribute("has-value", !!value);
    this.__updateTimePickerMinMax();
  }
  __dispatchChange() {
    this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
  }
  __minChanged(value, oldValue) {
    this.__handleDateTimeChange("min", "__minDateTime", value, oldValue);
    if (this.__datePicker) {
      this.__datePicker.min = this.__formatDateISO(this.__minDateTime, this.__defaultDateMinMaxValue);
    }
    this.__updateTimePickerMinMax();
  }
  __maxChanged(value, oldValue) {
    this.__handleDateTimeChange("max", "__maxDateTime", value, oldValue);
    if (this.__datePicker) {
      this.__datePicker.max = this.__formatDateISO(this.__maxDateTime, this.__defaultDateMinMaxValue);
    }
    this.__updateTimePickerMinMax();
  }
  __selectedDateTimeChanged(selectedDateTime) {
    const formattedValue = this.__formatDateTime(selectedDateTime);
    if (this.value !== formattedValue) {
      this.value = formattedValue;
    }
    const isDatePickerReady = Boolean(this.__datePicker && this.__datePicker.$);
    if (isDatePickerReady && !this.__ignoreInputValueChange) {
      this.__ignoreInputValueChange = true;
      const [dateValue, timeValue] = this.value.split("T");
      this.__datePicker.value = dateValue || "";
      this.__timePicker.value = timeValue || "";
      this.__ignoreInputValueChange = false;
    }
  }
  get __formattedValue() {
    const dateValue = this.__datePicker.value;
    const timeValue = this.__timePicker.value;
    if (dateValue && timeValue) {
      return [dateValue, timeValue].join("T");
    }
    return "";
  }
  __valueChangedEventHandler() {
    if (this.__ignoreInputValueChange) {
      return;
    }
    const value = this.__formattedValue;
    const [date, time] = value.split("T");
    this.__ignoreInputValueChange = true;
    this.__updateTimePickerMinMax();
    if (date && time) {
      if (value !== this.value) {
        this.value = value;
      }
    } else {
      this.value = "";
    }
    this.__ignoreInputValueChange = false;
  }
  __autoOpenDisabledChanged(autoOpenDisabled) {
    if (this.__datePicker) {
      this.__datePicker.autoOpenDisabled = autoOpenDisabled;
    }
    if (this.__timePicker) {
      this.__timePicker.autoOpenDisabled = autoOpenDisabled;
    }
  }
  __themeChanged(theme, datePicker, timePicker) {
    [datePicker, timePicker].forEach((picker) => {
      if (picker) {
        if (theme) {
          picker.setAttribute("theme", theme);
        } else {
          picker.removeAttribute("theme");
        }
      }
    });
  }
  __pickersChanged(datePicker, timePicker) {
    if (!datePicker || !timePicker) {
      return;
    }
    if (datePicker.__defaultPicker !== timePicker.__defaultPicker) {
      return;
    }
    if (datePicker.value) {
      this.__valueChangedEventHandler();
    } else if (this.value) {
      this.__selectedDateTimeChanged(this.__selectedDateTime);
    }
  }
};
customElements.define(DateTimePicker.is, DateTimePicker);
/**
 * @license
 * Copyright (c) 2021 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=@vaadin_date-time-picker_theme_lumo_vaadin-date-time-picker_js.js.map

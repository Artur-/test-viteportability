import "./chunk-EGRHWZRV.js";
import {
  FormLayout
} from "./chunk-A2ITNMUL.js";
import "./chunk-CSCUQH4A.js";
import {
  Grid
} from "./chunk-AFEZNLNU.js";
import "./chunk-PJLAJOIA.js";
import "./chunk-O4ZCZF4S.js";
import "./chunk-PDDM37OU.js";
import "./chunk-K5L2JQVM.js";
import "./chunk-V4BBJAIT.js";
import "./chunk-H5SSPSJM.js";
import "./chunk-EMVGQF52.js";
import "./chunk-4EQQPNFR.js";
import "./chunk-4V7HTHEB.js";
import "./chunk-E4PWA4PK.js";
import "./chunk-XMK3PKMX.js";
import "./chunk-UCCJDHTP.js";
import "./chunk-5IY3DZOH.js";
import "./chunk-FXDBZGKI.js";
import "./chunk-4YC3PK3E.js";
import "./chunk-HDZUK7DT.js";
import "./chunk-ZLYHCBTY.js";
import "./chunk-G7RHUQOA.js";
import "./chunk-PSOWVSIC.js";
import "./chunk-2QU43T3L.js";
import "./chunk-M63LEPKS.js";
import "./chunk-Q6RJT5AX.js";
import "./chunk-ULOSKMYL.js";
import "./chunk-3XUR5GO6.js";
import "./chunk-SWEWJURK.js";
import "./chunk-2WAZ2OPO.js";
import "./chunk-MRY7CVKJ.js";
import "./chunk-S4GF4HOW.js";
import "./chunk-EGRHWZRV.js";
import "./chunk-X5RCOUJL.js";
import "./chunk-6AVOQNQ4.js";
import "./chunk-W5WIT4JA.js";
import "./chunk-VBV2WJY4.js";
import "./chunk-VD23N2FG.js";
import "./chunk-Y3KRHGW3.js";
import {
  ElementMixin
} from "./chunk-6TGXYB6C.js";
import {
  Debouncer,
  timeOut
} from "./chunk-RUXXNLZ4.js";
import "./chunk-NJGA5XKB.js";
import "./chunk-UGRMV72L.js";
import "./chunk-SOI6EIGV.js";
import "./chunk-ESTDBV53.js";
import "./chunk-YRRWCJGV.js";
import "./chunk-CBMAWUYA.js";
import "./chunk-J5VFVUBT.js";
import "./chunk-GBF7XL6S.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-LYMUE5P7.js";
import {
  css
} from "./chunk-AILCGYJH.js";
import "./chunk-BHAZN44K.js";
import "./chunk-D4OAJTCX.js";
import "./chunk-BFXXBFHG.js";
import "./chunk-VXX3KNUF.js";
import "./chunk-ZNYRZO32.js";
import "./chunk-DYEQLZCC.js";
import "./chunk-KFEHHBXX.js";
import "./chunk-3GXLJMXG.js";
import "./chunk-XLE2I272.js";
import "./chunk-CGDXGGUU.js";
import "./chunk-5BR6CINV.js";
import {
  afterNextRender
} from "./chunk-5SUV3F4B.js";
import {
  FlattenedNodesObserver
} from "./chunk-OIQZQ3SK.js";
import {
  PolymerElement
} from "./chunk-YGHRZLAU.js";
import {
  html
} from "./chunk-5VJMXRGB.js";
import "./chunk-XALJ24ZG.js";
import "./chunk-GN24F3WZ.js";
import "./chunk-HDWYYSVS.js";
import "./chunk-PN57JW3E.js";
import "./chunk-FHJNRKKV.js";
import "./chunk-JJSCQCEV.js";
import "./chunk-PHKVH5MM.js";
import "./chunk-J6GZCXFQ.js";

// node_modules/.pnpm/@vaadin/crud@22.0.0-beta2/node_modules/@vaadin/crud/theme/vaadin-dialog-layout-overlay-styles.js
registerStyles("vaadin-dialog-overlay", css`
    :host([theme~='layout']) [part='overlay'],
    :host([theme~='layout']) [part='content'] {
      display: flex;
      flex-direction: column;
      padding: 0;
      max-height: 100vh;
    }

    :host([theme~='layout']) [part='overlay'] {
      max-width: 54em;
      min-width: 20em;
    }

    @media (max-width: 600px), (max-height: 600px) {
      :host([theme~='layout']) {
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        padding: 0;
      }

      :host([theme~='layout']) [part='overlay'] {
        height: 100vh;
        width: 100vw;
        border-radius: 0 !important;
      }

      :host([theme~='layout']) [part='content'] {
        flex: 1;
      }
    }
  `, { moduleId: "vaadin-dialog-layout-overlay" });

// node_modules/.pnpm/@vaadin/crud@22.0.0-beta2/node_modules/@vaadin/crud/theme/lumo/vaadin-crud-styles.js
registerStyles("vaadin-crud-edit", css`
    :host {
      font-family: 'lumo-icons', var(--lumo-font-family);
      font-size: var(--lumo-icon-size-m);
      line-height: 1;
      color: var(--lumo-primary-text-color);
      position: relative;
      background-color: var(--lumo-contrast-5pct);
      border-radius: var(--lumo-border-radius-m);
      width: var(--lumo-size-s);
      height: var(--lumo-size-s);
      cursor: var(--lumo-clickable-cursor);
    }

    :host::before {
      content: var(--lumo-icons-edit);
      width: var(--lumo-size-m);
      height: var(--lumo-size-m);
      line-height: var(--lumo-size-m);
      text-align: center;
      position: absolute;
      top: calc((var(--lumo-size-m) - var(--lumo-size-s)) / -2);
      left: calc((var(--lumo-size-m) - var(--lumo-size-s)) / -2);
    }

    :host::after {
      content: '';
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: inherit;
      background-color: currentColor;
      opacity: 0;
      transition: opacity 100ms;
    }

    :host(:hover)::after {
      opacity: 0.05;
    }

    :host(:active)::after {
      opacity: 0.12;
    }
  `, { moduleId: "lumo-crud-grid-edit" });
registerStyles("vaadin-crud", css`
    :host {
      font-family: var(--lumo-font-family);
    }

    [part='toolbar'] {
      padding: var(--lumo-space-s) var(--lumo-space-m);
      background-color: var(--lumo-contrast-5pct);
      border: 1px solid var(--lumo-contrast-10pct);
      border-top: none;
    }

    :host(:not([dir='rtl'])) [part='toolbar'] ::slotted(*:not(:first-child)) {
      margin-left: var(--lumo-space-s);
    }

    :host([dir='rtl']) [part='toolbar'] ::slotted(*:not(:first-child)) {
      margin-right: var(--lumo-space-s);
    }

    :host([theme~='no-border']) [part='toolbar'] {
      border: 0;
    }

    vaadin-grid-cell-content {
      text-overflow: ellipsis;
    }
  `, { moduleId: "lumo-crud" });
registerStyles("vaadin-dialog-layout", css`
    [part='header'] ::slotted(*) {
      margin-top: var(--lumo-space-s);
      margin-bottom: var(--lumo-space-s);
    }

    [part='scroller'] {
      padding: var(--lumo-space-l);
    }

    [part='footer'] {
      background-color: var(--lumo-contrast-5pct);
      padding: var(--lumo-space-s) var(--lumo-space-s);
    }

    [part='footer'] ::slotted(*) {
      margin-left: var(--lumo-space-s);
      margin-right: var(--lumo-space-s);
    }

    [part='editor'] {
      background: var(--lumo-base-color);
      box-sizing: border-box;
    }

    :host(:not([editor-position=''])) [part='editor']:not([hidden]) {
      box-shadow: var(--lumo-box-shadow-m);
    }

    :host(:not([theme~='no-border']):not([editor-position=''])) [part='editor']:not([hidden]) {
      border: 1px solid var(--lumo-contrast-20pct);
    }

    :host(:not([theme~='no-border'])[editor-position='bottom']) [part='editor']:not([hidden]) {
      border-top: 0;
    }

    :host(:not([dir='rtl'])[editor-position='aside']) [part='editor']:not([hidden]) {
      border-left: 0;
    }

    :host([dir='rtl']:not([theme~='no-border'])[editor-position='aside']) [part='editor']:not([hidden]) {
      border-right: 0;
    }
  `, { moduleId: "lumo-dialog-layout" });

// node_modules/.pnpm/@vaadin/crud@22.0.0-beta2/node_modules/@vaadin/crud/src/vaadin-dialog-layout.js
var DialogLayout = class extends ElementMixin(ThemableMixin(PolymerElement)) {
  static get is() {
    return "vaadin-dialog-layout";
  }
  static get template() {
    return html`
      <style>
        :host {
          z-index: 1;
        }

        :host(:not([editor-position=''])[opened]:not([mobile])) {
          flex: 1 0 100%;
        }

        :host([editor-position='bottom'][opened]:not([mobile])) {
          max-height: var(--vaadin-crud-editor-max-height);
        }

        :host([editor-position='aside'][opened]:not([mobile])) {
          min-width: 300px;
          max-width: var(--vaadin-crud-editor-max-width);
        }

        [part='editor'] {
          display: flex;
          flex-direction: column;
          height: 100%;
        }

        [part='editor'][hidden] {
          display: none;
        }

        :host([editor-position='bottom']) [part='editor']:not([hidden]) {
          height: 100%;
          display: flex;
          flex-direction: column;
        }

        [part='scroller'] {
          display: flex;
          flex-direction: column;
          overflow: auto;
          -webkit-overflow-scrolling: touch;
          flex: auto;
        }

        [part='footer'] {
          display: flex;
          flex: none;
          flex-direction: row-reverse;
        }
      </style>

      <div id="editor" part="editor" hidden$="[[!_computeEditorOpened(opened, mobile, 'bottom','aside')]]">
        <div part="scroller" id="scroller" role="group" aria-labelledby="header">
          <div part="header" id="header">
            <slot name="header"></slot>
          </div>
          <slot></slot>
        </div>

        <div part="footer" role="toolbar">
          <slot name="footer"></slot>
        </div>
      </div>

      <vaadin-dialog
        id="dialog"
        opened="[[_computeEditorOpened(opened, mobile, '')]]"
        aria-label="[[__ariaLabel]]"
        no-close-on-outside-click="[[noCloseOnOutsideClick]]"
        no-close-on-esc="[[noCloseOnEsc]]"
        theme$="[[theme]] layout"
      ></vaadin-dialog>

      <template id="dialogTemplate"></template>
    `;
  }
  static get properties() {
    return {
      opened: {
        type: Boolean,
        value: false,
        notify: true,
        reflectToAttribute: true,
        observer: "_openedChanged"
      },
      editorPosition: {
        type: String,
        reflectToAttribute: true
      },
      theme: String,
      noCloseOnOutsideClick: Boolean,
      noCloseOnEsc: Boolean,
      form: Object,
      saveButton: Object,
      deleteButton: Object,
      cancelButton: Object,
      mobile: {
        type: Boolean,
        observer: "__mobileChanged",
        reflectToAttribute: true
      },
      __ariaLabel: String
    };
  }
  ready() {
    super.ready();
    this._dialogOpenedChangedListener = this._dialogOpenedChangedListener.bind(this);
    this.$.dialog.addEventListener("opened-changed", this._dialogOpenedChangedListener);
    this.__header = this.querySelector("[slot=header]");
    this.__footer = Array.from(this.querySelectorAll('[slot="footer"]'));
  }
  _dialogOpenedChangedListener() {
    this.opened = this.$.dialog.opened;
  }
  _openedChanged(opened) {
    if (opened) {
      this._ensureChildren();
    }
    this.$.dialog.$.overlay.template = this.$.dialogTemplate;
    this.$.scroller.scrollTop = 0;
  }
  __mobileChanged() {
    this._ensureChildren();
  }
  __moveChildNodes(target) {
    target.appendChild(this.__header);
    if (this.form.hasAttribute("slot")) {
      this.form.removeAttribute("slot");
    }
    target.appendChild(this.form);
    if (this.saveButton) {
      this.saveButton.setAttribute("slot", "footer");
      target.appendChild(this.saveButton);
    }
    if (this.cancelButton) {
      this.cancelButton.setAttribute("slot", "footer");
      target.appendChild(this.cancelButton);
    }
    this.__footer.forEach((node) => target.appendChild(node));
    if (this.deleteButton) {
      this.deleteButton.setAttribute("slot", "footer");
      target.appendChild(this.deleteButton);
    }
    setTimeout(() => {
      this.__ariaLabel = this.__header.textContent.trim();
    });
  }
  _ensureChildren() {
    const content = this.$.dialog.$.overlay.$.content;
    if (!this.form || !content.shadowRoot) {
      return;
    }
    if (this.editorPosition === "" || this.mobile) {
      Array.from(this.$.editor.childNodes).forEach((node) => content.shadowRoot.appendChild(node));
      this.__moveChildNodes(content);
    } else {
      Array.from(content.shadowRoot.childNodes).forEach((c) => this.$.editor.appendChild(c));
      this.__moveChildNodes(this);
    }
  }
  _computeEditorOpened(opened, isMobile, ...editorPositions) {
    if (isMobile && editorPositions.indexOf("") !== -1) {
      return opened;
    }
    return editorPositions.indexOf(this.editorPosition) !== -1 && opened;
  }
};
customElements.define(DialogLayout.is, DialogLayout);

// node_modules/.pnpm/@vaadin/grid@22.0.0-beta2/node_modules/@vaadin/grid/src/vaadin-grid-filter.js
var GridFilter = class extends class extends PolymerElement {
} {
  static get template() {
    return html`
      <style>
        :host {
          display: inline-flex;
          max-width: 100%;
        }

        #filter {
          width: 100%;
          box-sizing: border-box;
        }
      </style>
      <slot name="filter">
        <vaadin-text-field id="filter" value="{{value}}"></vaadin-text-field>
      </slot>
    `;
  }
  static get is() {
    return "vaadin-grid-filter";
  }
  static get properties() {
    return {
      path: String,
      value: {
        type: String,
        notify: true
      },
      _connected: Boolean
    };
  }
  connectedCallback() {
    super.connectedCallback();
    this._connected = true;
  }
  static get observers() {
    return ["_filterChanged(path, value, _connected)"];
  }
  ready() {
    super.ready();
    const child = this.firstElementChild;
    if (child && child.getAttribute("slot") !== "filter") {
      console.warn('Make sure you have assigned slot="filter" to the child elements of <vaadin-grid-filter>');
      child.setAttribute("slot", "filter");
    }
  }
  _filterChanged(path, value, connected) {
    if (path === void 0 || value === void 0 || !connected) {
      return;
    }
    if (this._previousValue === void 0 && value === "") {
      return;
    }
    this._previousValue = value;
    this._debouncerFilterChanged = Debouncer.debounce(this._debouncerFilterChanged, timeOut.after(200), () => {
      this.dispatchEvent(new CustomEvent("filter-changed", { bubbles: true }));
    });
  }
  focus() {
    this.$.filter.focus();
  }
};
customElements.define(GridFilter.is, GridFilter);

// node_modules/.pnpm/@vaadin/crud@22.0.0-beta2/node_modules/@vaadin/crud/src/vaadin-crud-include-mixin.js
var IncludedMixin = (superClass) => class IncludedMixin extends superClass {
  static get properties() {
    return {
      exclude: {
        value: "^_",
        observer: "__onExcludeChange"
      },
      include: {
        observer: "__onIncludeChange"
      }
    };
  }
  __onExcludeChange(exclude) {
    if (typeof exclude == "string") {
      this.exclude = exclude ? RegExp(exclude.replace(/, */g, "|"), "i") : void 0;
    }
  }
  __onIncludeChange(include) {
    if (typeof include == "string") {
      this.include = include ? include.split(/, */) : void 0;
    } else if (!this._fields && Array.isArray(include)) {
      const item = {};
      this.include.forEach((path) => this.__set(path, null, item));
      this._configure(item);
    }
  }
};

// node_modules/.pnpm/@vaadin/crud@22.0.0-beta2/node_modules/@vaadin/crud/src/vaadin-crud-grid.js
var CrudGrid = class extends IncludedMixin(Grid) {
  static get is() {
    return "vaadin-crud-grid";
  }
  static get properties() {
    return {
      noFilter: Boolean,
      noSort: Boolean,
      noHead: Boolean,
      __hideEditColumn: Boolean
    };
  }
  static get observers() {
    return ["__onItemsChange(items)", "__onHideEditColumnChange(hideEditColumn)"];
  }
  __onItemsChange(items) {
    if ((!this.dataProvider || this.dataProvider == this._arrayDataProvider) && !this.include && items && items[0]) {
      this._configure(items[0]);
    }
  }
  __onHideEditColumnChange() {
    if (this.firstChild) {
      this.__toggleEditColumn();
    }
  }
  __toggleEditColumn() {
    const el = this.querySelector("vaadin-crud-edit-column");
    if (this.hideEditColumn) {
      el && this.removeChild(el);
    } else if (!el) {
      this.appendChild(document.createElement("vaadin-crud-edit-column"));
    }
  }
  __dataProviderWrapper(params, callback) {
    this.__dataProvider(params, (items, size) => {
      if (this.innerHTML == "" && !this.include && items[0]) {
        this._configure(items[0]);
      }
      callback(items, size);
    });
  }
  _dataProviderChanged(dataProvider, oldDataProvider) {
    if (this._arrayDataProvider == dataProvider) {
      super._dataProviderChanged(dataProvider, oldDataProvider);
    } else if (this.__dataProviderWrapper != dataProvider) {
      this.innerHTML = "";
      this.__dataProvider = dataProvider;
      this.dataProvider = this.__dataProviderWrapper;
      super._dataProviderChanged(this.__dataProviderWrapper, oldDataProvider);
    }
  }
  _configure(item) {
    this.innerHTML = "";
    this.__createColumns(this, item);
    this.__toggleEditColumn();
  }
  _generateHeader(path) {
    return path.substr(path.lastIndexOf(".") + 1).replace(/([A-Z])/g, "-$1").toLowerCase().replace(/-/g, " ").replace(/^./, (match) => match.toUpperCase());
  }
  __createColumn(parent, path) {
    const col = document.createElement("vaadin-grid-column");
    col.renderer = (root, column, model) => {
      root.textContent = path ? this.get(path, model.item) : model.item;
    };
    if (!this.noHead && path) {
      col.headerRenderer = (root) => {
        const label = this._generateHeader(path);
        if (!this.noSort) {
          const sorter = window.document.createElement("vaadin-grid-sorter");
          sorter.setAttribute("path", path);
          sorter.textContent = label;
          root.appendChild(sorter);
        }
        if (!this.noFilter) {
          const filter = window.document.createElement("vaadin-grid-filter");
          filter.setAttribute("path", path);
          filter.style.display = "flex";
          const textField = window.document.createElement("vaadin-text-field");
          textField.setAttribute("theme", "small");
          textField.setAttribute("slot", "filter");
          textField.setAttribute("focus-target", true);
          textField.style.width = "100%";
          this.noSort && (textField.placeholder = label);
          textField.addEventListener("value-changed", function(event) {
            filter.value = event.detail.value;
          });
          filter.appendChild(textField);
          root.appendChild(filter);
        }
        if (this.noSort && this.noFilter) {
          root.textContent = label;
        }
      };
    }
    parent.appendChild(col);
    return col;
  }
  __createColumns(parent, object, path) {
    if (typeof object === "object") {
      Object.keys(object).forEach((prop) => {
        if (!this.include && this.exclude && this.exclude.test(prop)) {
          return;
        }
        const newPath = (path ? `${path}.` : "") + prop;
        if (object[prop] && typeof object[prop] === "object") {
          const group = this.noHead ? parent : this.__createGroup(parent, newPath, object[prop]);
          this.__createColumns(group, object[prop], newPath);
        } else {
          this.__createColumn(parent, newPath);
        }
      });
    } else {
      this.__createColumn(parent, "");
    }
  }
  __createGroup(parent, path) {
    const grp = document.createElement("vaadin-grid-column-group");
    grp.headerRenderer = (root) => root.textContent = this.__capitalize(path.replace(/^.*\./, ""));
    parent.appendChild(grp);
    return grp;
  }
  __capitalize(path) {
    return path.toLowerCase().replace(/([^\w]+)/g, " ").trim().replace(/^./, (c) => c.toUpperCase());
  }
  __set(path, val, obj) {
    if (obj && path) {
      path.split(".").slice(0, -1).reduce((o, p) => o[p] = o[p] || {}, obj);
      this.set(path, val, obj);
    }
  }
};
customElements.define(CrudGrid.is, CrudGrid);

// node_modules/.pnpm/@vaadin/crud@22.0.0-beta2/node_modules/@vaadin/crud/src/vaadin-crud-form.js
var CrudForm = class extends IncludedMixin(FormLayout) {
  static get is() {
    return "vaadin-crud-form";
  }
  static get properties() {
    return {
      item: Object
    };
  }
  static get observers() {
    return ["__onItemChange(item)"];
  }
  _configure(object) {
    this.innerHTML = "";
    this._fields = [];
    this.__createFields(this, object);
    this.notifyResize();
  }
  __onItemChange(item) {
    if (!this._fields) {
      this._configure(item);
    }
  }
  __createField(parent, path) {
    const field = document.createElement("vaadin-text-field");
    field.label = this.__capitalize(path);
    field.path = path;
    field.required = true;
    parent.appendChild(field);
    this._fields.push(field);
    return field;
  }
  __createFields(parent, object, path) {
    Object.keys(object).forEach((prop) => {
      if (!this.include && this.exclude && this.exclude.test(prop)) {
        return;
      }
      const newPath = (path ? `${path}.` : "") + prop;
      if (object[prop] && typeof object[prop] === "object") {
        this.__createFields(parent, object[prop], newPath);
      } else {
        this.__createField(parent, newPath);
      }
    });
    if (!this._fields.length) {
      this._fields = void 0;
    }
  }
  __capitalize(path) {
    return path.toLowerCase().replace(/([^\w]+)/g, " ").trim().replace(/^./, (c) => c.toUpperCase());
  }
  __set(path, val, obj) {
    if (obj && path) {
      path.split(".").slice(0, -1).reduce((o, p) => o[p] = o[p] || {}, obj);
      this.set(path, val, obj);
    }
  }
};
customElements.define(CrudForm.is, CrudForm);

// node_modules/.pnpm/@vaadin/crud@22.0.0-beta2/node_modules/@vaadin/crud/src/vaadin-crud.js
var HOST_PROPS = {
  save: [{ attr: "disabled", prop: "__isDirty", parseProp: "__isSaveBtnDisabled" }, { prop: "i18n.saveItem" }],
  cancel: [{ prop: "i18n.cancel" }],
  delete: [{ attr: "hidden", prop: "__isNew", parseProp: (prop) => prop }, { prop: "i18n.deleteItem" }]
};
var Crud = class extends ElementMixin(ThemableMixin(PolymerElement)) {
  static get template() {
    return html`
      <style>
        :host {
          --vaadin-crud-editor-max-height: 40%;
          --vaadin-crud-editor-max-width: 40%;
        }

        :host,
        #main {
          display: flex;
          flex-direction: column;
          height: 400px;
          flex: 1 1 100%;
          align-self: stretch;
          position: relative;
          overflow: hidden;
        }

        #main {
          height: 100%;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='toolbar'] {
          display: flex;
          flex-shrink: 0;
          align-items: baseline;
          justify-content: flex-end;
        }

        :host([no-toolbar]) [part='toolbar'] {
          display: none;
        }

        #container {
          display: flex;
          height: 100%;
        }

        :host([editor-position='bottom']) #container {
          flex-direction: column;
        }
      </style>

      <div id="container">
        <div id="main">
          <slot name="grid">
            <vaadin-crud-grid
              theme$="[[theme]]"
              id="grid"
              include="[[include]]"
              exclude="[[exclude]]"
              no-sort="[[noSort]]"
              no-filter="[[noFilter]]"
              no-head="[[noHead]]"
              hide-edit-column="[[editOnClick]]"
            ></vaadin-crud-grid>
          </slot>

          <div id="toolbar" part="toolbar" on-click="__new">
            <slot name="toolbar">
              <vaadin-button new-button="" id="new" theme="primary">[[i18n.newItem]]</vaadin-button>
            </slot>
          </div>
        </div>
        <vaadin-dialog-layout
          theme$="[[theme]]"
          form="[[_form]]"
          save-button="[[_saveButton]]"
          cancel-button="[[_cancelButton]]"
          delete-button="[[_deleteButton]]"
          id="dialog"
          no-close-on-outside-click="[[__isDirty]]"
          no-close-on-esc="[[__isDirty]]"
          opened="{{editorOpened}}"
          editor-position$="{{editorPosition}}"
          mobile="[[__mobile]]"
          theme="crud"
        >
          <h3 slot="header">[[__computeEditorHeader(__isNew, i18n.newItem, i18n.editItem)]]</h3>
          <div id="editor">
            <slot name="form">
              <vaadin-crud-form
                theme$="[[theme]]"
                id="form"
                include="[[include]]"
                exclude="[[exclude]]"
              ></vaadin-crud-form>
            </slot>
          </div>

          <slot name="save-button">
            <vaadin-button id="save" on-click="__save" theme="primary" disabled$="[[__isSaveBtnDisabled(__isDirty)]]">
              [[i18n.saveItem]]
            </vaadin-button>
          </slot>
          <slot name="cancel-button">
            <vaadin-button id="cancel" on-click="__cancelBound" theme="tertiary">[[i18n.cancel]]</vaadin-button>
          </slot>
          <div slot="footer" style="flex: auto;"></div>
          <slot name="delete-button">
            <vaadin-button id="delete" on-click="__delete" theme="tertiary error" hidden$="[[__isNew]]"
              >[[i18n.deleteItem]]</vaadin-button
            >
          </slot>
        </vaadin-dialog-layout>
      </div>

      <vaadin-confirm-dialog
        theme$="[[theme]]"
        id="confirmCancel"
        on-confirm="__confirmCancel"
        cancel
        confirm-text="[[i18n.confirm.cancel.button.confirm]]"
        cancel-text="[[i18n.confirm.cancel.button.dismiss]]"
        header="[[i18n.confirm.cancel.title]]"
        message="[[i18n.confirm.cancel.content]]"
        confirm-theme="primary"
      ></vaadin-confirm-dialog>
      <vaadin-confirm-dialog
        theme$="[[theme]]"
        id="confirmDelete"
        on-confirm="__confirmDelete"
        cancel
        confirm-text="[[i18n.confirm.delete.button.confirm]]"
        cancel-text="[[i18n.confirm.delete.button.dismiss]]"
        header="[[i18n.confirm.delete.title]]"
        message="[[i18n.confirm.delete.content]]"
        confirm-theme="primary error"
      ></vaadin-confirm-dialog>

      <iron-media-query query="[[__mobileMediaQuery]]" query-matches="{{__mobile}}"></iron-media-query>
    `;
  }
  static get is() {
    return "vaadin-crud";
  }
  static get properties() {
    return {
      _grid: {
        type: HTMLElement,
        observer: "__onGridChange"
      },
      _form: {
        type: HTMLElement,
        observer: "__onFormChange"
      },
      _saveButton: {
        type: HTMLElement,
        observer: "__onSaveButtonChange"
      },
      _deleteButton: {
        type: HTMLElement,
        observer: "__onDeleteButtonChange"
      },
      _cancelButton: {
        type: HTMLElement,
        observer: "__onCancelButtonChange"
      },
      items: {
        type: Array,
        notify: true,
        observer: "__onItemsChange"
      },
      editedItem: {
        type: Object,
        observer: "__onItemChange",
        notify: true
      },
      editorPosition: {
        type: String,
        value: "",
        reflectToAttribute: true,
        observer: "__onEditorPositionChange"
      },
      editOnClick: {
        type: Boolean,
        value: false
      },
      dataProvider: {
        type: Function,
        observer: "__onDataProviderChange"
      },
      noFilter: Boolean,
      noSort: Boolean,
      noHead: Boolean,
      include: String,
      exclude: String,
      editorOpened: {
        type: Boolean,
        notify: true,
        observer: "__onOpenedChanged"
      },
      size: {
        type: Number,
        readOnly: true,
        notify: true
      },
      noToolbar: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      i18n: {
        type: Object,
        value: function() {
          return {
            newItem: "New item",
            editItem: "Edit item",
            saveItem: "Save",
            cancel: "Cancel",
            deleteItem: "Delete...",
            editLabel: "Edit",
            confirm: {
              delete: {
                title: "Delete item",
                content: "Are you sure you want to delete this item? This action cannot be undone.",
                button: {
                  confirm: "Delete",
                  dismiss: "Cancel"
                }
              },
              cancel: {
                title: "Discard changes",
                content: "There are unsaved changes to this item.",
                button: {
                  confirm: "Discard",
                  dismiss: "Cancel"
                }
              }
            }
          };
        }
      },
      __isDirty: Boolean,
      __isNew: Boolean,
      __mobileMediaQuery: {
        value: "(max-width: 600px), (max-height: 600px)"
      },
      __mobile: {
        type: Boolean,
        observer: "__mobileChanged"
      }
    };
  }
  static get observers() {
    return [
      "__onI18Change(i18n, _grid)",
      "__onEditOnClickChange(editOnClick, _grid)",
      "__hostPropsChanged(" + HOST_PROPS.save.map(({ prop }) => prop).join(",") + "," + HOST_PROPS.cancel.map(({ prop }) => prop).join(",") + "," + HOST_PROPS.delete.map(({ prop }) => prop).join(",") + ")"
    ];
  }
  static _finalizeClass() {
    super._finalizeClass();
    const devModeCallback = window.Vaadin.developmentModeCallback;
    const licenseChecker = devModeCallback && devModeCallback["vaadin-license-checker"];
    if (typeof licenseChecker === "function") {
      licenseChecker(Crud);
    }
  }
  constructor() {
    super();
    this._observer = new FlattenedNodesObserver(this, (info) => {
      this.__onDomChange(info.addedNodes);
    });
  }
  ready() {
    super.ready();
    this.__editListener = (e) => this.__onCrudGridEdit(e);
    this.__changeListener = (e) => this.__onFormChanges(e);
    this.__saveBound = this.__save.bind(this);
    this.__cancelBound = this.__cancel.bind(this);
    this.__deleteBound = this.__delete.bind(this);
    this.__gridSizeListener = this.__onGridSizeChanges.bind(this);
    this.__boundEditOnClickListener = this.__editOnClickListener.bind(this);
    this._grid = this.$.grid;
    this._form = this.$.form;
    this._saveButton = this.$.save;
    this._deleteButton = this.$.delete;
    this._cancelButton = this.$.cancel;
    this.$.dialog.$.dialog.$.overlay.addEventListener("vaadin-overlay-outside-click", this.__cancelBound);
    this.$.dialog.$.dialog.$.overlay.addEventListener("vaadin-overlay-escape-press", this.__cancelBound);
  }
  __isSaveBtnDisabled(isDirty) {
    return !isDirty;
  }
  __computeEditorHeader(isNew, newItem, editItem) {
    return isNew ? newItem : editItem;
  }
  __onI18Change(i18n, grid) {
    if (!grid) {
      return;
    }
    afterNextRender(grid, () => {
      Array.from(grid.querySelectorAll("vaadin-crud-edit-column")).forEach((column) => {
        column.ariaLabel = i18n.editLabel;
      });
    });
  }
  __onEditorPositionChange(editorPosition) {
    if (Crud._isValidEditorPosition(editorPosition)) {
      return;
    }
    this.editorPosition = "";
  }
  static _isValidEditorPosition(editorPosition) {
    return ["bottom", "aside"].indexOf(editorPosition) != -1;
  }
  __onOpenedChanged(opened, old) {
    if (!opened && old) {
      this.__closeEditor();
    } else {
      this.__onFormChange(this._form);
    }
    this.__toggleToolbar();
  }
  __mobileChanged() {
    this.__toggleToolbar();
  }
  __toggleToolbar() {
    if (this.editorPosition === "bottom" && !this.__mobile) {
      this.$.toolbar.style.display = this.editorOpened ? "none" : "";
    }
  }
  __onDomChange(nodes) {
    nodes.forEach((node) => {
      if (node.getAttribute) {
        const slotAttributeValue = node.getAttribute("slot");
        if (!slotAttributeValue) {
          return;
        }
        if (slotAttributeValue == "grid") {
          this.__onEditOnClickChange(false, this._grid);
          this._grid = node;
          this.__onEditOnClickChange(this.editOnClick, this._grid);
        } else if (slotAttributeValue == "form") {
          this._form = node;
        } else if (slotAttributeValue.indexOf("button") >= 0) {
          const [button] = slotAttributeValue.split("-");
          this[`_${button}Button`] = node;
        }
      }
    });
  }
  __onCrudGridEdit(e) {
    e.stopPropagation();
    this.__confirmBeforeChangingEditedItem(e.detail.item);
  }
  __onFormChanges() {
    this.__isDirty = true;
  }
  __onGridSizeChanges() {
    this._setSize(this._grid.size);
  }
  __onGridChange(grid, old) {
    if (old) {
      old.removeEventListener("edit", this.__editListener);
      old.removeEventListener("size-changed", this.__gridSizeListener);
    }
    if (this.items) {
      this.__onItemsChange(this.items);
    }
    if (this.editedItem) {
      this.__onItemChange(this.editedItem);
    }
    grid.addEventListener("edit", this.__editListener);
    grid.addEventListener("size-changed", this.__gridSizeListener);
    this.__onGridSizeChanges();
  }
  __onFormChange(form, old) {
    if (old && old.parentElement) {
      old.parentElement && old.parentElement.removeChild(old);
      old.removeEventListener("change", this.__changeListener);
      old.removeEventListener("input", this.__changeListener);
    }
    if (!form) {
      return;
    }
    if (this.items) {
      this.__onItemsChange(this.items);
    }
    if (this.editedItem) {
      this.__onItemChange(this.editedItem);
    }
    form.addEventListener("change", this.__changeListener);
    form.addEventListener("input", this.__changeListener);
  }
  __onSaveButtonChange(save, old) {
    this.__setupSlottedButton(save, old, this.__saveBound);
  }
  __onDeleteButtonChange(deleteButton, old) {
    this.__setupSlottedButton(deleteButton, old, this.__deleteBound);
  }
  __onCancelButtonChange(cancel, old) {
    this.__setupSlottedButton(cancel, old, this.__cancelBound);
  }
  __setupSlottedButton(slottedButton, currentButton, clickListener) {
    if (currentButton && currentButton.parentElement) {
      currentButton.parentElement.removeChild(currentButton);
    }
    if (slottedButton.parentElement === this) {
      slottedButton.addEventListener("click", clickListener);
    }
  }
  __hostPropsChanged() {
    this.__propagateHostAttributes();
  }
  __propagateHostAttributes() {
    this.__propagateHostAttributesToButton(this._saveButton, HOST_PROPS.save);
    this.__propagateHostAttributesToButton(this._cancelButton, HOST_PROPS.cancel);
    this.__propagateHostAttributesToButton(this._deleteButton, HOST_PROPS.delete);
  }
  __propagateHostAttributesToButton(button, props) {
    if (button) {
      props.forEach(({ attr, prop, parseProp }) => {
        if (prop.indexOf("i18n") >= 0) {
          button.textContent = this.i18n[prop.split(".")[1]];
        } else {
          if (typeof parseProp === "string") {
            this._setOrToggleAttribute(attr, this[parseProp](this[prop]), button);
            return;
          }
          this._setOrToggleAttribute(attr, parseProp(this[prop]), button);
        }
      });
    }
  }
  _setOrToggleAttribute(name, value, node) {
    if (!name || !node) {
      return;
    }
    if (value) {
      node.setAttribute(name, typeof value === "boolean" ? "" : value);
    } else {
      node.removeAttribute(name);
    }
  }
  __onDataProviderChange(dataProvider) {
    if (this._grid) {
      this._grid.dataProvider = this.__createDataProviderProxy(dataProvider);
    }
  }
  __onEditOnClickChange(rowToEditChange, _grid) {
    if (!_grid) {
      return;
    }
    if (rowToEditChange) {
      _grid.addEventListener("active-item-changed", this.__boundEditOnClickListener);
    } else {
      _grid.removeEventListener("active-item-changed", this.__boundEditOnClickListener);
    }
  }
  __editOnClickListener(event) {
    const item = event.detail.value;
    if (this.editorOpened && this.__isDirty) {
      this.__confirmBeforeChangingEditedItem(item);
      return;
    }
    if (item) {
      this.__edit(item);
    } else if (!this.__keepOpened) {
      this.__closeEditor();
    }
  }
  __confirmBeforeChangingEditedItem(item, keepOpened) {
    if (this.editorOpened && this.__isDirty && this.editedItem !== item) {
      this.$.confirmCancel.opened = true;
      const listenOnce = (event) => {
        event.preventDefault();
        if (item || keepOpened) {
          this.__edit(item);
          this.__clearItemAndKeepEditorOpened(item, keepOpened);
        } else {
          this.__closeEditor();
        }
        this.removeEventListener("cancel", listenOnce);
      };
      this.addEventListener("cancel", listenOnce);
    } else {
      this.__edit(item);
      this.__clearItemAndKeepEditorOpened(item, keepOpened);
    }
  }
  __clearItemAndKeepEditorOpened(item, keepOpened) {
    if (!item) {
      setTimeout(() => {
        this.__keepOpened = keepOpened;
        this.editedItem = this._grid.activeItem = void 0;
      });
    }
  }
  __createDataProviderProxy(dataProvider) {
    return (params, callback) => {
      const callbackProxy = (chunk, size) => {
        if (chunk && chunk[0]) {
          this.__model = chunk[0];
        }
        callback(chunk, size);
      };
      dataProvider(params, callbackProxy);
    };
  }
  __onItemsChange(items) {
    if (this.items && this.items[0]) {
      this.__model = items[0];
    }
    if (this._grid) {
      this._grid.items = items;
    }
  }
  __onItemChange(item) {
    if (!this._form) {
      return;
    }
    if (item) {
      if (!this._fields.length && this._form._configure) {
        if (this.__model) {
          this._form._configure(this.__model);
        } else {
          console.warn("<vaadin-crud> Unable to autoconfigure form because the data structure is unknown. Either specify `include` or ensure at least one item is available beforehand.");
        }
      }
      this._form.item = item;
      this._fields.forEach((e) => {
        const path = e.path || e.getAttribute("path");
        path && (e.value = this.get(path, item));
      });
      this.__isNew = this.__isNew || this.items && this.items.indexOf(item) < 0;
      this.editorOpened = true;
    }
  }
  get _fields() {
    if (!this.__fields || !this.__fields.length) {
      this.__fields = Array.from(this._form.querySelectorAll("*")).filter((e) => e.validate || e.checkValidity);
    }
    return this.__fields;
  }
  __validate() {
    return this._fields.every((e) => (e.validate || e.checkValidity).call(e));
  }
  __setHighlightedItem(item) {
    if (this._grid === this.$.grid) {
      this._grid.selectedItems = item ? [item] : [];
    }
  }
  __closeEditor() {
    this.editorOpened = false;
    this.__isDirty = false;
    this.__setHighlightedItem(null);
    setTimeout(() => this.__clearItemAndKeepEditorOpened(null, false));
  }
  __new(event) {
    if (event.composedPath().filter((e) => e.nodeType == 1 && e.hasAttribute("new-button"))[0]) {
      this.__confirmBeforeChangingEditedItem(null, true);
    }
  }
  __edit(item) {
    if (this.editedItem === item) {
      return;
    }
    this.__setHighlightedItem(item);
    this.__openEditor("edit", item);
  }
  __openEditor(type, item) {
    this.__isDirty = false;
    this.__isNew = !item;
    const evt = this.dispatchEvent(new CustomEvent(this.__isNew ? "new" : "edit", { detail: { item }, cancelable: true }));
    if (evt) {
      this.editedItem = item || {};
    } else {
      this.editorOpened = true;
    }
  }
  __save() {
    if (!this.__validate()) {
      return;
    }
    const item = Object.assign({}, this.editedItem);
    this._fields.forEach((e) => {
      const path = e.path || e.getAttribute("path");
      path && this.__set(path, e.value, item);
    });
    const evt = this.dispatchEvent(new CustomEvent("save", { detail: { item }, cancelable: true }));
    if (evt) {
      if (this.__isNew && !this.dataProvider) {
        if (!this.items) {
          this.items = [item];
        } else {
          this.items.push(item);
        }
      } else {
        Object.assign(this.editedItem, item);
      }
      this._grid.clearCache();
      this.__closeEditor();
    }
  }
  __cancel() {
    if (this.__isDirty) {
      this.$.confirmCancel.opened = true;
    } else {
      this.__confirmCancel();
    }
  }
  __confirmCancel() {
    const evt = this.dispatchEvent(new CustomEvent("cancel", { detail: { item: this.editedItem }, cancelable: true }));
    if (evt) {
      this.__closeEditor();
    }
  }
  __delete() {
    this.$.confirmDelete.opened = true;
  }
  __confirmDelete() {
    const evt = this.dispatchEvent(new CustomEvent("delete", { detail: { item: this.editedItem }, cancelable: true }));
    if (evt) {
      if (this.items && this.items.indexOf(this.editedItem) >= 0) {
        this.items.splice(this.items.indexOf(this.editedItem), 1);
      }
      this._grid.clearCache();
      this.__closeEditor();
    }
  }
  __set(path, val, obj) {
    if (obj && path) {
      path.split(".").slice(0, -1).reduce((o, p) => o[p] = o[p] || {}, obj);
      this.set(path, val, obj);
    }
  }
};
customElements.define(Crud.is, Crud);
/**
 * @license
 * Copyright (c) 2017 - 2021 Vaadin Ltd.
 * This program is available under Commercial Vaadin Developer License 4.0, available at https://vaadin.com/license/cvdl-4.0.
 */
/**
 * @license
 * Copyright (c) 2021 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=@vaadin_crud_theme_lumo_vaadin-crud_js.js.map
